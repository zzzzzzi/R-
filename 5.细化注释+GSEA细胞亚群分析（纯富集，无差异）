library(Seurat)
library(enrichplot)
library(fgsea)
library(tidyverse)
library(DOSE)
library(org.Hs.eg.db)
#重新分析seurat对象，找更精细的亚群（基于粗略的基础上，例如前面发现TAM细胞，这次可以对TAM进行细分）
library(ggplot2) 
#更大的resolution
seu <- FindClusters(sce, resolution = 0.4)
#可视化
DimPlot(seu, reduction = "umap",repel = T,
        cols = c("#D4419EFF","#E0918BFF","#CDBB4CFF","#E5AD4FFF","#C871B7FF","#5D5087FF","#639CA4FF","#AEC6C7FF","#65C5D6FF","#D1ECCAFF","#21409FFF","#65024BFF","#588B39FF","#505A23FF"),
        pt.size = 0.5, label = T, label.size=12, label.box =T, group.by = "RNA_snn_res.0.4") 
#找亚群marker（最好在自己组内找便于注释，群体找是为了能在bulk中分析这群细胞的数目）
seu_res0.4_markers <- FindAllMarkers(object = seu, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
#找出来的feature做一个dotmap图
features <- c("CCL3","CCL4L2","IL1B","DLL3","PTPRZ1","ETV1","GPR17","TNR",
"ATCAY","P2RY12","C1QA","AIF1","SPARCL1","ID4","CLU","PLP1","MBP","ERMN","SPP1",
"APOC1","APOC2","TOP2A","CENPF","H2AFZ","CLDN5","IFI27","IGFBP7","CCL5","IL7R",
"S100A4","TNK2","AC009041.2","KCNQ1OT1","PPP1R14A","LINC00689","SOX4","CADM2")
DotPlot(seu, features = features, assay="RNA", cols = c("#FFDB01","#0E197D")) + coord_flip()

#个性化分析 ICB可视化
Immune_Checkpoint <- c("CTLA4","LAG3","PDCD1","TIGIT")
DotPlot(seu, features = Immune_Checkpoint, assay="RNA", cols = c("#E7B800","#22763FFF"), group.by = "RNA_snn_res.0.4") + coord_flip()

#如何细化注释TAM亚群，就是把每个小亚群和其他的进行差异分析
seu_TAM <- subset(seu, idents = c("0","3","6"))
DEG_myeloid_C0 <- FindMarkers(seu_TAM, ident.1 = "0", ident.2 = c("3", "6"), logfc.threshold = 0.25)
DEG_myeloid_C6 <- FindMarkers(seu_TAM, ident.1 = "6", ident.2 = c("3", "0"), logfc.threshold = 0.25)

#找到这个几个亚群后，做GSEA富集分析
# --- 步骤 1: 准备GSEA所需的预排序基因列表 ---
# GSEA分析的核心是需要一个“预排序的基因列表”。这个列表是一个向量(vector)，
# 其中每个元素的值是该基因的某个统计量（如此处的log2FC），而每个元素的名字是对应的基因名。

# 将行名（通常是基因符号）复制到一个名为'SYMBOl'的新列中。
# 这是为了方便后续使用dplyr包的函数进行操作，因为dplyr处理列比处理行名更直接。
DEG_myeloid_C0$SYMBOl <- rownames(DEG_myeloid_C0)

# 根据p值筛选基因。这里只保留p_val小于0.05的基因。
# **注意**: 对于GSEA分析，通常推荐使用【所有】检测到的基因进行排序，而不仅仅是差异显著的基因。
# 这是因为GSEA的威力在于检测一群基因的协同、微小的变化，预先筛选可能会丢失这部分信息。
# 在实际分析中，你可以考虑注释掉或删除此行。
DEG_myeloid_C0 <- DEG_myeloid_C0[DEG_myeloid_C0$p_val < 0.05, ]

# 创建一个用于排序的中间数据框'Pre.genes'。
# 1. `arrange(desc(avg_log2FC))`: 按照avg_log2FC（平均log2倍数变化）列进行【降序】排列。
#    这使得上调最显著的基因排在最前面，下调最显著的基因排在最后面。
# 2. `dplyr::select(SYMBOl, avg_log2FC)`: 只选择基因名和log2FC这两列。
Pre.genes <- DEG_myeloid_C0 %>%
  arrange(desc(avg_log2FC)) %>%
  dplyr::select(SYMBOl, avg_log2FC)

# 使用`deframe()`函数将两列的数据框转换为一个命名的数值型向量'ranks'。
# `deframe()`会把第一列（SYMBOl）作为向量的【名字】，第二列（avg_log2FC）作为向量的【值】。
# 这个'ranks'就是fgsea函数所需要的标准输入格式。
ranks <- deframe(Pre.genes)


# --- 步骤 2: 加载基因集并运行GSEA ---

# 使用`gmtPathways()`函数从.gmt文件中加载基因集（pathways）。
# .gmt文件是存储基因集的标准格式，这里加载的是MSigDB数据库中的Hallmark通路。
# `pathways.hallmark`会成为一个列表，其中每个元素是一个通路，包含了该通路下的所有基因。
pathways.hallmark <- gmtPathways("h.all.v2023.1.Hs.symbols.gmt")

# 执行fgsea分析。
# `pathways`: 提供要测试的通路基因集。
# `stats`: 提供预排序的基因列表。
# `nperm`: 指定用于计算p值的置换检验次数。1000次是比较快的设置，若要追求更精确的p值，可增加到10000次。
fgseaRes <- fgsea(pathways = pathways.hallmark, stats = ranks, nperm = 1000)

# --- 步骤 3: 整理并排序结果 ---

# 将fgsea的输出结果转换为更易于查看的tibble格式，并进行排序。
# 1. `as_tibble()`: 转换为tibble格式。
# 2. `arrange(desc(NES))`: 按照NES（Normalized Enrichment Score，标准化富集分数）进行【降序】排列。
#    NES为正值表示通路在排序列表的顶端（即上调基因中）富集；NES为负值表示在底端（即下调基因中）富集。
#    这样排序后，富集最显著的上调相关通路会显示在最前面，方便查看。
fgseaResTidy <- fgseaRes %>%
  as_tibble() %>%
  arrange(desc(NES))

#显示前15条
fgseaResTidy_top15 <- fgseaResTidy[1:15,]
#可视化
ggplot(fgseaResTidy_top15, aes(reorder(pathway, -log10(pval)), -log10(pval))) +
  geom_col(aes(fill=NES)) + coord_flip() +
  labs(x="Pathway", y="-log10(pval)") + scale_fill_gradient(low = "#D4419EFF",high = "yellow") + theme_minimal()
